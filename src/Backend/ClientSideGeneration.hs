{-# LANGUAGE TemplateHaskell #-}
module ClientSideGeneration (generateWorld) where
import Elm.Module
import Elm.Derive
import Elm.TyRep
import World
import Data.Proxy
import Character
import Bullet

Elm.Derive.deriveElmDef Elm.Derive.defaultOptions ''World
Elm.Derive.deriveElmDef Elm.Derive.defaultOptions ''Player
Elm.Derive.deriveElmDef Elm.Derive.defaultOptions ''Enemy
Elm.Derive.deriveElmDef Elm.Derive.defaultOptions ''Bullet

generateWorld :: IO ()
generateWorld =
    putStrLn $ moduleHeader "World" ++ vec2Json ++ makeModuleContentWithAlterations (defaultAlterations . myAlteration)
    [ DefineElm (Proxy :: Proxy World),
      DefineElm (Proxy :: Proxy Player),
      DefineElm (Proxy :: Proxy Enemy),
      DefineElm (Proxy :: Proxy Bullet)
    ] 
    
myAlteration :: ETypeDef -> ETypeDef
myAlteration = recAlterType $ \t -> case t of
            ETyCon (ETCon "Id") -> ETyCon (ETCon "String")
            -- Do not use V2 with something other than a float if you plan on sending it to Elm
            ETyApp (ETyCon (ETCon "V2")) _ -> ETyCon (ETCon "Vec2") 
            _ -> t   
            
--I don't thing there is a better way of doing that, since we're not creating the datatype       
--Might break if the package update  
vec2Json :: String 
vec2Json = unlines ["jsonDecVec2 = Decode.object2 vec2",
    "  (\"x\" := Decode.float)",
    "  (\"y\" := Decode.float)",
    "",
    "jsonEncVec2 vector =",
    "  let (x,y) = toTuple vector",
    "  in  Encode.object [(\"x\", Encode.float x), (\"y\", Encode.float y)]",
    ""]
    
moduleHeader :: String -> String
moduleHeader moduleName = unlines
     [ "--THIS IS AN AUTOGENERATED FILES, DO NOT MODIFY"
     , "module " ++ moduleName ++ " where"
     , ""
     , "import Json.Decode"
     , "import Json.Decode exposing ((:=))"
     , "import Json.Encode exposing (Value)"
     , "-- The following module comes from bartavelle/json-helpers"
     , "import Json.Helpers exposing (..)"
     , "import Vec2 exposing (..)"
     , ""
     , ""
     ]